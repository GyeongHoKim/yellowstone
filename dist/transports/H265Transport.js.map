{"version":3,"file":"H265Transport.js","sourceRoot":"","sources":["../../lib/transports/H265Transport.ts"],"names":[],"mappings":"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","sourcesContent":["// Process SDP and RTP packets\n// De-packetize RTP packets to re-create H265 NAL Units\n// Write H265 NAL units to a .265 file\n\nimport RTSPClient from \"../RTSPClient\";\nimport { RTPPacket } from \"../util\";\n\nimport * as transform from \"sdp-transform\";\nimport { Writable } from \"stream\";\n\n// .h265 file header\nconst H265_HEADER = Buffer.from([0x00, 0x00, 0x00, 0x01]);\n\ninterface Details {\n  codec: string\n  mediaSource: transform.MediaDescription\n  rtpChannel: number,\n  rtcpChannel: number\n}\n\nexport default class H265Transport {\n  client: RTSPClient;\n  stream: Writable;\n  has_donl = false;\n\n  rtpPackets: Buffer[] = [];\n\n  constructor(client: RTSPClient, stream: Writable, details: Details) {\n    this.client = client;\n    this.stream = stream;\n\n    // process 'fmtp' (which is optional in the SDP)\n    this.processConnectionDetails(details);\n\n    client.on(\"data\", (channel, data, packet) => {\n      if (channel == details.rtpChannel) {\n        this.processRTPPacket(packet);\n      }\n    });\n\n  }\n\n  processConnectionDetails(details: Details): void {\n    // Extract the VPS, SPS and PPS from the MediaSource part of the SDP.\n    // NOTE the H265 RTP standard makes this optional and we may need to extract this from the RTP payload\n    // as inband VPS/SPS/PPS instead\n    const fmtp = (details.mediaSource.fmtp)[0];\n\n    if (!fmtp) {\n      return;\n    }\n\n    const fmtpConfig = transform.parseParams(fmtp.config);\n    const vps = Buffer.from(fmtpConfig['sprop-vps'].toString(), \"base64\");\n    const sps = Buffer.from(fmtpConfig['sprop-sps'].toString(), \"base64\");\n    const pps = Buffer.from(fmtpConfig['sprop-pps'].toString(), \"base64\");\n\n    this.stream.write(H265_HEADER);\n    this.stream.write(vps);\n    this.stream.write(H265_HEADER);\n    this.stream.write(sps);\n    this.stream.write(H265_HEADER);\n    this.stream.write(pps);\n  }\n\n  processRTPPacket(packet: RTPPacket): void {\n    // Accumatate RTP packets\n    this.rtpPackets.push(packet.payload);\n\n    // When Marker is set to 1 pass the group of packets to processRTPFrame()\n    if (packet.marker == 1) {\n      this.processRTPFrame(this.rtpPackets);\n      this.rtpPackets = [];\n    }\n  }\n\n  processRTPFrame(rtpPackets: Buffer[]): void {\n    const nals = [];\n    let partialNal = [];\n\n    for (let i = 0; i < rtpPackets.length; i++) {\n\n      // Examine the first two bytes of the RTP data, the Payload Header\n      // F (Forbidden Bit),\n      // Type of NAL Unit (or VCL NAL Unit if Type is < 32),\n      // LayerId\n      // TID  (TemporalID = TID - 1)\n      /*+---------------+---------------+\n        *|0|1|2|3|4|5|6|7|0|1|2|3|4|5|6|7|\n        *+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        *|F|   Type    |  LayerId  | TID |\n        *+-------------+-----------------+\n        */\n      const packet = rtpPackets[i];\n\n      const payload_header = (packet[0] << 8) | (packet[1]);\n      const payload_header_f_bit = (payload_header >> 15) & 0x01;\n      const payload_header_type = (payload_header >> 9) & 0x3F;\n      const payload_header_layer_id = (payload_header >> 3) & 0x3F;\n      const payload_header_tid = payload_header & 0x7;\n\n      // There are three ways to Packetize NAL units into RTP Packets\n      //  Single NAL Unit Packet\n      //  Aggregation Packet (payload_header_type = 48)\n      //  Fragmentation Unit (payload_header_type = 49)\n\n\n      // Single NAL Unit Packet\n      // 32=VPS\n      // 33=SPS\n      // 34=PPS\n      if (payload_header_type != 48 && payload_header_type != 49) {\n        //TODO - Handle DONL\n        nals.push(packet);\n      }\n\n      // Aggregation Packet\n      else if (payload_header_type == 48) {\n        // TODO\n        console.log(\"eek\");\n      }\n\n\n      // Fragmentation Unit\n      else if (payload_header_type == 49) {\n        //Console.WriteLine(\"Fragmentation Unit\");\n\n        //    0 1 2 3 4 5 6 7\n        //   +-+-+-+-+-+-+-+-+\n        //   |S|E|  FuType   |\n        //   +---------------+\n       //\n\n        // Parse Fragmentation Unit Header\n        const fu_header_s = (packet[2] >> 7) & 0x01;  // start marker\n        const fu_header_e = (packet[2] >> 6) & 0x01;  // end marker\n        const fu_header_type = (packet[2] >> 0) & 0x3F; // fu type\n\n        // Console.WriteLine(\"Frag FU-A s=\" + fu_header_s + \"e=\" + fu_header_e);\n\n        // Check Start and End flags\n        if (fu_header_s == 1 && fu_header_e == 0) {\n          // Start Fragment.\n          // Initiise the partialNal byte array\n\n          // Empty the partial NAL array\n          partialNal = [];\n\n          // Reconstrut the NAL header from the rtp_payload_header, replacing the Type with FU Type\n          let nal_header = (payload_header & 0x81FF); // strip out existing 'type'\n          nal_header = nal_header | (fu_header_type << 9);\n\n          partialNal.push((nal_header >> 8) & 0xFF);\n          partialNal.push((nal_header >> 0) & 0xFF);\n        }\n\n\n        // Copy the video data\n        if (this.has_donl) {\n          // start copying after the DONL data\n          for (let x = 5; x < packet.length; x++) {\n            partialNal.push(packet[x]); // not very efficient, copying one byte at a time\n          }\n        }\n        else {\n          // there is no DONL data\n          for (let x = 3; x < packet.length; x++) {\n            partialNal.push(packet[x]); // not very efficient, copying one byte at a time\n          }\n        }\n\n        if (fu_header_s == 0 && fu_header_e == 1) {\n          // End Fragment\n          // Append this payload to the fragmented_nal\n\n          // Add the NAL to the array of NAL units\n          nals.push(Buffer.from(partialNal));\n        }\n      }\n      else {\n        //Console.WriteLine(\"Unknown Payload Header Type = \" + payload_header_type);\n      }\n    }\n\n    // Write out all the NALs\n    for (let x = 0; x < nals.length; x++) {\n      this.stream.write(H265_HEADER);\n      this.stream.write(nals[x]);\n    }\n  }\n}\n"]}