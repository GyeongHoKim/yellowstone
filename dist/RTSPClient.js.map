{"version":3,"file":"RTSPClient.js","sourceRoot":"","sources":["../lib/RTSPClient.ts"],"names":[],"mappings":";;AAAA,2BAA2B;AAC3B,+BAA+B;AAC/B,6BAAwC;AACxC,mCAAsC;AAEtC,iCAOgB;AAEhB,2CAA2C;AAC3C,sDAA+C;AAC/C,MAAM,OAAO,GAAG,SAAS,CAAC;AAE1B,MAAM,SAAS,GAAG,GAAG,CAAC;AACtB,MAAM,aAAa,GAAG,GAAG,CAAC;AAE1B,gCAAgC;AAChC,uBAAuB;AACvB,qCAAqC;AACrC,uCAAuC;AAEvC,sCAAsC;AACtC,wCAAwC;AACxC,qCAAqC;AACrC,qHAAqH;AACrH,mCAAmC;AAEnC,6BAA6B;AAC7B,QAAQ;AACR,4BAA4B;AAC5B,oDAAoD;AACpD,8BAA8B;AAC9B,4BAA4B;AAC5B,8BAA8B;AAC9B,+CAA+C;AAC/C,EAAE;AACF,gCAAgC;AAChC,4FAA4F;AAC5F,iNAAiN;AACjN,sEAAsE;AAEtE,MAAM,QAAQ,GAAG,kBAAkB,CAAC;AACpC,MAAM,cAAc,GAAG,IAAI,MAAM,CAAC,iFAAiF,EAAE,GAAG,CAAC,CAAC;AAE1H,IAAK,UAMJ;AAND,WAAK,UAAU;IACb,qDAAS,CAAA;IACT,yEAAmB,CAAA;IACnB,2EAAoB,CAAA;IACpB,iFAAuB,CAAA;IACvB,uEAAkB,CAAA;AACpB,CAAC,EANI,UAAU,KAAV,UAAU,QAMd;AA4BD,MAAqB,UAAW,SAAQ,qBAAY;IA4ClD,YACE,QAAgB,EAChB,QAAgB,EAChB,OAAmC;QAEnC,KAAK,EAAE,CAAC;QA5CV,gBAAW,GAAG,KAAK,CAAC;QACpB,WAAM,GAAG,KAAK,CAAC;QAMf,UAAK,GAAG,CAAC,CAAC;QAKV,gCAA2B,GAAG,CAAC,CAAC;QAChC,qBAAgB,GAAG,IAAI,CAAC;QAExB,cAAS,GAAe,UAAU,CAAC,SAAS,CAAC;QAE7C,uCAAuC;QACvC,iDAAiD;QACjD,iBAAY,GAAa,EAAE,CAAC;QAE5B,mCAAmC;QAEnC,6CAA6C;QAC7C,sBAAiB,GAAG,CAAC,CAAC;QACtB,mBAAc,GAAG,EAAE,CAAC;QACpB,gBAAW,GAAY,EAAE,CAAC;QAE1B,uCAAuC;QAEvC,qBAAgB,GAAG,CAAC,CAAC;QACrB,eAAU,GAAW,IAAI,MAAM,CAAC,EAAE,CAAC,CAAC;QACpC,sBAAiB,GAAG,CAAC,CAAC;QAEtB,iCAAiC;QACjC,eAAU,GAAG,IAAA,mBAAY,GAAE,CAAC;QAE5B,cAAS,GAAe,IAAI,GAAG,CAAC,MAAM,EAAE,CAAC;QACzC,gBAAW,GAAkB,EAAE,CAAC;QAQ9B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,mCACP,CAAC,OAAO,IAAI,EAAE,CAAC,KAClB,YAAY,EAAE,iBAAiB,GAChC,CAAC;IACJ,CAAC;IAED,qDAAqD;IACrD,YAAY;IACZ,EAAE;IACF,iBAAiB;IACjB,EAAE;IACF,uDAAuD;IACvD,YAAY;IACZ,WAAW,CAAC,QAAgB,EAAE,IAAY;QACxC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,+BAA+B;YAE/B,MAAM,aAAa,GAAG,CAAC,GAAQ,EAAE,EAAE;gBACjC,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;gBAC9C,MAAM,CAAC,GAAG,CAAC,CAAC;YACd,CAAC,CAAC;YAEF,MAAM,aAAa,GAAG,GAAG,EAAE;gBACzB,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;gBAC9C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YACnB,CAAC,CAAC;YAEF,MAAM,gBAAgB,GAAG,CAAC,YAAoB,EAAE,OAAgB,EAAE,EAAE;gBAClE,MAAM,IAAI,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;gBAExC,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;oBAC/B,OAAO;iBACR;gBAED,IAAI,IAAI,KAAK,UAAU,IAAI,IAAI,KAAK,UAAU,EAAE;oBAC9C,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,IAAI,EAAE,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;iBAChD;gBAED,IAAI,IAAI,KAAK,UAAU,IAAI,OAAO,CAAC,QAAQ,EAAE;oBAC3C,IAAI,CAAC,KAAK,EAAE,CAAC;oBACb,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;iBAChC;YACH,CAAC,CAAC;YAEF,MAAM,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,QAAQ,EAAE,GAAG,EAAE;gBAC9C,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;gBACxB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;gBAEtB,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;gBAE9C,IAAI,CAAC,EAAE,CAAC,UAAU,EAAE,gBAAgB,CAAC,CAAC;gBACtC,OAAO,CAAC,IAAI,CAAC,CAAC;YAChB,CAAC,CAAC,CAAC;YAEH,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAC3C,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;YAClC,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;YAClC,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,KAAK,CAAC,OAAO,CACX,GAAW,EACX,EACE,SAAS,GAAG,IAAI,EAChB,UAAU,GAAG,KAAK,MACiC;QACjD,SAAS,EAAE,IAAI;QACf,UAAU,EAAE,KAAK;KAClB;QAEH,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,IAAA,WAAQ,EAAC,CAAC,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC;QACvD,IAAI,CAAC,QAAQ,EAAE;YACb,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;SACzD;QAED,MAAM,OAAO,GAAa,EAAE,CAAC;QAE7B,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,QAAQ,CAAC,IAAI,IAAI,KAAK,CAAC,CAAC,CAAC;QAC1D,MAAM,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAE9B,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;YACjD,MAAM,EAAE,iBAAiB;SAC1B,CAAC,CAAC;QACH,IAAI,CAAC,WAAW,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE;YAC7C,MAAM,IAAI,KAAK,CACb,oEAAoE,CACrE,CAAC;SACH;QAED,sCAAsC;QACtC,MAAM,EAAE,KAAK,EAAE,GAAG,SAAS,CAAC,KAAK,CAAC,WAAW,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;QAEzE,oEAAoE;QACpE,gGAAgG;QAChG,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,IAAI,QAAQ,GAAG,KAAK,CAAC;QACrB,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,IAAI,cAAc,GAAG,KAAK,CAAC;QAE3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,IAAI,SAAS,GAAG,KAAK,CAAC;YACtB,IAAI,KAAK,GAAG,EAAE,CAAC;YACf,MAAM,WAAW,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YAG7B,kHAAkH;YAClH,mCAAmC;YACnC,IAAI,WAAW,CAAC,SAAS,IAAI,SAAS;gBAAE,WAAW,CAAC,SAAS,GAAG,UAAU,CAAC,CAAC,mCAAmC;YAE/G,IACE,WAAW,CAAC,IAAI,KAAK,OAAO;gBAC5B,WAAW,CAAC,QAAQ,KAAK,OAAO;gBAChC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,MAAM,EACnC;gBACA,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,gCAAgC,EAAE,EAAE,CAAC,CAAC;gBACvD,IAAI,QAAQ,IAAI,KAAK,EAAE;oBACrB,SAAS,GAAG,IAAI,CAAC;oBACjB,QAAQ,GAAG,IAAI,CAAC;oBAChB,KAAK,GAAG,MAAM,CAAC;iBAChB;aACF;YAED,IACE,WAAW,CAAC,IAAI,KAAK,OAAO;gBAC5B,WAAW,CAAC,QAAQ,KAAK,OAAO;gBAChC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,MAAM,EACnC;gBACA,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,gCAAgC,EAAE,EAAE,CAAC,CAAC;gBACvD,IAAI,QAAQ,IAAI,KAAK,EAAE;oBACrB,SAAS,GAAG,IAAI,CAAC;oBACjB,QAAQ,GAAG,IAAI,CAAC;oBAChB,KAAK,GAAG,MAAM,CAAC;iBAChB;aACF;YAGD,IACE,WAAW,CAAC,IAAI,KAAK,OAAO;gBAC5B,CAAC,WAAW,CAAC,SAAS,KAAK,UAAU,IAAI,WAAW,CAAC,SAAS,KAAK,UAAU,CAAC;gBAC9E,WAAW,CAAC,QAAQ,KAAK,OAAO;gBAChC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,KAAK,eAAe,IAAI,6DAA6D;gBAC3H,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAC1C;gBACA,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,+BAA+B,EAAE,EAAE,CAAC,CAAC;gBACtD,IAAI,QAAQ,IAAI,KAAK,EAAE;oBACrB,SAAS,GAAG,IAAI,CAAC;oBACjB,QAAQ,GAAG,IAAI,CAAC;oBAChB,KAAK,GAAG,KAAK,CAAC;iBACf;aACF;YAED,IAAI,WAAW,CAAC,IAAI,KAAK,OAAO;gBAC9B,WAAW,CAAC,SAAS,KAAK,UAAU;gBACpC,WAAW,CAAC,QAAQ,KAAK,OAAO,EAAE;gBAClC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,gCAAgC,EAAE,EAAE,CAAC,CAAC;gBACvD,IAAI,cAAc,IAAI,KAAK,EAAE;oBAC3B,SAAS,GAAG,IAAI,CAAC;oBACjB,cAAc,GAAG,IAAI,CAAC;oBACtB,KAAK,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;iBAClC;aACF;YAED,IACE,WAAW,CAAC,IAAI,KAAK,aAAa;gBAClC,WAAW,CAAC,QAAQ,KAAK,OAAO;gBAChC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,EAAE,KAAK,oBAAoB,EAC/D;gBACA,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,8BAA8B,EAAE,EAAE,CAAC,CAAC;gBACrD,IAAI,WAAW,IAAI,KAAK,EAAE;oBACxB,SAAS,GAAG,IAAI,CAAC;oBACjB,WAAW,GAAG,IAAI,CAAC;oBACnB,KAAK,GAAG,oBAAoB,CAAC;iBAC9B;aACF;YAED,IAAI,SAAS,EAAE;gBACb,IAAI,SAAS,GAAG,EAAE,CAAC;gBACnB,6DAA6D;gBAC7D,IAAI,WAAW,CAAC,OAAO,EAAE;oBACvB,IAAI,WAAW,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;wBAC3D,gBAAgB;wBAChB,SAAS,GAAG,WAAW,CAAC,OAAO,CAAC;qBACjC;yBAAM;wBACL,gBAAgB;wBAChB,SAAS,GAAG,IAAI,CAAC,IAAI,GAAG,GAAG,GAAG,WAAW,CAAC,OAAO,CAAC;qBACnD;iBACF;gBAED,mCAAmC;gBACnC,gCAAgC;gBAChC,qFAAqF;gBACrF,IAAI,QAAQ,CAAC;gBACb,IAAI,UAAU,CAAC;gBACf,IAAI,WAAW,CAAC;gBAChB,IAAI,WAAW,GAAsB,IAAI,CAAC,CAAC,sBAAsB;gBACjE,IAAI,YAAY,GAAsB,IAAI,CAAC,CAAC,sBAAsB;gBAElE,IAAI,UAAU,KAAK,KAAK,EAAE;oBACxB,6DAA6D;oBAC7D,iCAAiC;oBAEjC,UAAU,GAAG,IAAI,CAAC,gBAAgB,CAAC;oBACnC,WAAW,GAAG,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;oBACxC,IAAI,CAAC,gBAAgB,IAAI,CAAC,CAAC;oBAE3B,MAAM,OAAO,GAAG,UAAU,CAAC;oBAC3B,WAAW,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;oBAEzC,WAAW,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,EAAE;wBACxC,MAAM,MAAM,GAAG,IAAA,qBAAc,EAAC,GAAG,CAAC,CAAC;wBACnC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;oBACrD,CAAC,CAAC,CAAC;oBAEH,MAAM,QAAQ,GAAG,WAAW,CAAC;oBAC7B,YAAY,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;oBAE1C,YAAY,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,GAAG,EAAE,MAAM,EAAE,EAAE;wBACzC,MAAM,MAAM,GAAG,IAAA,sBAAe,EAAC,GAAG,CAAC,CAAC;wBACpC,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;wBAE3C,MAAM,eAAe,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;wBACpD,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;oBAClE,CAAC,CAAC,CAAC;oBAEH,yCAAyC;oBAEzC,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;wBAC5B,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,IAAI,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;oBAChD,CAAC,CAAC,CAAC;oBAEH,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;wBAC5B,YAAY,aAAZ,YAAY,uBAAZ,YAAY,CAAE,IAAI,CAAC,QAAQ,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;oBAClD,CAAC,CAAC,CAAC;oBAEH,MAAM,WAAW,GAAG;wBAClB,SAAS,EAAE,+BAA+B,OAAO,IAAI,QAAQ,EAAE;qBAChE,CAAC;oBACF,IAAI,IAAI,CAAC,QAAQ;wBACf,MAAM,CAAC,MAAM,CAAC,WAAW,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;oBACzD,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;iBAChE;qBAAM,IAAI,UAAU,KAAK,KAAK,EAAE;oBAC/B,iBAAiB;oBACjB,kBAAkB;oBAElB,UAAU,GAAG,IAAI,CAAC,2BAA2B,CAAC;oBAC9C,WAAW,GAAG,IAAI,CAAC,2BAA2B,GAAG,CAAC,CAAC;oBACnD,IAAI,CAAC,2BAA2B,IAAI,CAAC,CAAC;oBAEtC,MAAM,WAAW,GAAG;wBAClB,SAAS,EAAE,2BAA2B,UAAU,IAAI,WAAW,EAAE;qBAClE,CAAC;oBACF,IAAI,IAAI,CAAC,QAAQ;wBACf,MAAM,CAAC,MAAM,CAAC,WAAW,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,0BAA0B;oBACpF,QAAQ,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;iBAChE;qBAAM;oBACL,MAAM,IAAI,KAAK,CACb,iDAAiD,UAAU,mBAAmB,CAC/E,CAAC;iBACH;gBAED,IAAI,CAAC,QAAQ,EAAE;oBACb,MAAM,IAAI,KAAK,CACb,yDAAyD,CAC1D,CAAC;iBACH;gBAED,MAAM,EAAE,OAAO,EAAE,GAAG,QAAQ,CAAC;gBAE7B,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;oBACtB,MAAM,IAAI,KAAK,CACb,oEAAoE,CACrE,CAAC;iBACH;gBAED,MAAM,SAAS,GAAG,IAAA,qBAAc,EAAC,OAAO,CAAC,SAAS,CAAC,CAAC;gBACpD,IACE,SAAS,CAAC,QAAQ,KAAK,aAAa;oBACpC,SAAS,CAAC,QAAQ,KAAK,SAAS,EAChC;oBACA,MAAM,IAAI,KAAK,CACb,0FAA0F,CAC3F,CAAC;iBACH;gBAED,qCAAqC;gBACrC,uEAAuE;gBACvE,mEAAmE;gBACnE,iFAAiF;gBACjF,uGAAuG;gBACvG,IAAI,UAAU,KAAK,KAAK,IAAI,SAAS,IAAI,WAAW,IAAI,YAAY,EAAE;oBACpE,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;oBACvG,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;iBACzG;gBAED,IAAI,OAAO,CAAC,WAAW,EAAE;oBACvB,IAAI,CAAC,sBAAsB,GAAG,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBAC9D;gBAED,IAAI,OAAO,CAAC,OAAO,EAAE;oBACnB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC/C;gBAED,MAAM,MAAM,GAAW;oBACrB,KAAK;oBACL,WAAW;oBACX,SAAS,EAAE,SAAS,CAAC,UAAU;oBAC/B,MAAM,EAAE,KAAK,KAAK,MAAM;oBACxB,UAAU;oBACV,WAAW;iBACZ,CAAC;gBAEF,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACtB,CAAC,qBAAqB;SACxB,CAAC,+CAA+C;QAEjD,IAAI,SAAS,EAAE;YACb,sEAAsE;YACtE,uBAAuB;YACvB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC,GAAG,EAAE;gBACnC,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;gBACpD,kCAAkC;YACpC,CAAC,EAAE,EAAE,GAAG,IAAI,CAAC,CAAC;SACf;QAED,IAAI,CAAC,WAAW,GAAG,OAAO,CAAC;QAC3B,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,OAAO,CACL,WAAmB,EACnB,eAAwB,EAAE,EAC1B,GAAY;QAEZ,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;SAC1B;QAED,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC;QACxB,8BAA8B;QAC9B,IAAI,GAAG,GAAG,GAAG,WAAW,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,sBAAsB,EAAE,MAAM,CAAC;QAE3E,MAAM,OAAO,mCACR,IAAI,CAAC,OAAO,GACZ,YAAY,CAChB,CAAC;QAEF,QAAQ;QACR,sEAAsE;QACtE,0EAA0E;QAC1E,iFAAiF;QAEjF,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;aAC3B,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,KAAK,KAAK,MAAM,CAAC;aAC7C,IAAI,CAAC,EAAE,CAAC,CAAC;QAEZ,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;QAC9B,oDAAoD;QACpD,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC;QAEjC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,MAAM,eAAe,GAAG,CACtB,YAAoB,EACpB,UAAmB,EACnB,YAAsB,EACtB,EAAE;gBACF,MAAM,WAAW,GAAW,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;gBACzD,IAAI,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,eAAe,IAAI,OAAO,EAAE;oBACjE,6FAA6F;oBAC7F,MAAM,CAAC,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC,CAAC;oBAC3C,OAAO;iBACR;gBACD,IAAI,UAAU,CAAC,IAAI,KAAK,EAAE,EAAE;oBAC1B,OAAO;iBACR;gBAED,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,eAAe,CAAC,CAAC;gBAEjD,MAAM,UAAU,GAAG,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBAExD,IAAI,UAAU,KAAK,SAAS,EAAE;oBAC5B,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;wBAC3B,OAAO,CAAC;4BACN,OAAO,EAAE,UAAU;4BACnB,YAAY;yBACb,CAAC,CAAC;qBACJ;yBAAM;wBACL,OAAO,CAAC;4BACN,OAAO,EAAE,UAAU;yBACpB,CAAC,CAAC;qBACJ;iBACF;qBAAM;oBACL,MAAM,UAAU,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC;oBAExC,uCAAuC;oBACvC,IAAI,UAAU,KAAK,aAAa,IAAI,UAAU,EAAE;wBAC9C,MAAM,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;wBAEtC,4CAA4C;wBAC5C,IAAI,KAAK,GAAG,EAAE,CAAC;wBACf,IAAI,KAAK,GAAG,EAAE,CAAC;wBAEf,IAAI,KAAK,GAAG,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBAC5C,OAAO,KAAK,IAAI,IAAI,EAAE;4BACpB,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;4BAEtB,IAAI,IAAI,IAAI,OAAO,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE;gCAC/B,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;6BAClB;4BAED,IAAI,IAAI,IAAI,OAAO,IAAI,KAAK,CAAC,CAAC,CAAC,EAAE;gCAC/B,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;6BAClB;4BAED,KAAK,GAAG,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;yBACzC;wBAED,+CAA+C;wBAC/C,IAAI,UAAU,GAAG,EAAE,CAAC;wBAEpB,IAAI,IAAI,KAAK,QAAQ,EAAE;4BACrB,wBAAwB;4BAExB,MAAM,GAAG,GAAG,IAAA,iBAAU,EACpB,GAAG,IAAI,CAAC,QAAQ,IAAI,KAAK,IAAI,IAAI,CAAC,QAAQ,EAAE,CAC7C,CAAC;4BACF,MAAM,GAAG,GAAG,IAAA,iBAAU,EAAC,GAAG,WAAW,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;4BACtD,MAAM,GAAG,GAAG,IAAA,iBAAU,EAAC,GAAG,GAAG,IAAI,KAAK,IAAI,GAAG,EAAE,CAAC,CAAC;4BAEjD,UAAU,GAAG,oBAAoB,IAAI,CAAC,QAAQ,YAAY,KAAK,YAAY,KAAK,UAAU,IAAI,CAAC,IAAI,eAAe,GAAG,GAAG,CAAC;yBAC1H;6BAAM,IAAI,IAAI,KAAK,OAAO,EAAE;4BAC3B,uBAAuB;4BACvB,wBAAwB;4BACxB,MAAM,GAAG,GAAG,IAAI,MAAM,CACpB,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,EAAE,CACpC,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;4BACrB,UAAU,GAAG,SAAS,GAAG,EAAE,CAAC;yBAC7B;wBAED,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE;4BACrB,aAAa,EAAE,UAAU;yBAC1B,CAAC,CAAC;wBAEH,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,OAAO,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,4CAA4C;wBAC9F,OAAO;qBACR;oBAED,MAAM,CAAC,IAAI,KAAK,CAAC,wBAAwB,UAAU,GAAG,CAAC,CAAC,CAAC;oBACzD,OAAO;iBACR;YACH,CAAC,CAAC;YAEF,IAAI,CAAC,EAAE,CAAC,UAAU,EAAE,eAAe,CAAC,CAAC;QACvC,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO,CAAC,MAAc,EAAE,eAAwB,EAAE;QAChD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,OAAO;SACR;QAED,8BAA8B;QAC9B,IAAI,GAAG,GAAG,YAAY,MAAM,MAAM,CAAC;QAEnC,MAAM,OAAO,mCACR,IAAI,CAAC,OAAO,GACZ,YAAY,CAChB,CAAC;QAEF,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC;aAC3B,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,GAAG,GAAG,KAAK,KAAK,MAAM,CAAC;aAC7C,IAAI,CAAC,EAAE,CAAC,CAAC;QAEZ,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;QAC9B,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC;IACnC,CAAC;IAED,KAAK,CAAC,IAAI;QACR,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC7C;QAED,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;IACzD,CAAC;IAED,KAAK,CAAC,KAAK;QACT,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC7C;QAED,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC1D,CAAC;IAED,KAAK,CAAC,oBAAoB,CAAC,UAAkB;QAC3C,IAAI,GAAG,EAAE,GAAG,CAAC;QACb,MAAM,OAAO,GAAG,GAAG,CAAC;QACpB,OAAO,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE;YAC5B,IAAI,UAAU,CAAC,MAAM,GAAG,OAAO,EAAE;gBAC/B,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;gBACnC,UAAU,GAAG,UAAU,CAAC,KAAK,CAAC,OAAO,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC;aAC3D;iBAAM;gBACL,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC;gBAC7C,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aAC9B;YACD,IAAI,CAAC,GAAG;gBACN,GAAG,GAAG,IAAI,mBAAS,CAAC,GAAG,CAAC,CAAC;;gBAEzB,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC;YACpB,2BAA2B;YAC3B,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,MAAM,CAAC;YACvB,GAAG,CAAC,GAAG,EAAE,CAAC;YACV,MAAM,YAAY,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YACrC,YAAY,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;YACjD,IAAI,kBAAkB,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE;gBACzD,OAAO,KAAK,CAAC,WAAW,CAAC,IAAI,KAAK,OAAO,IAAI,KAAK,CAAC,WAAW,CAAC,SAAS,KAAK,UAAU,CAAC;YAC1F,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC;YAC5B;;;cAGE;YACF,kBAAkB,GAAG,kBAAkB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;YACtD,IAAI,iBAAiB,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA,UAAU;YACtD,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,iBAAiB,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,CAAC;YAC1F,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,iBAAiB,EAAE,YAAY,CAAC,CAAC,CAAC;YACrE,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,iBAAiB,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;YAClE,MAAM,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;SACrD;QACD,OAAO;IACT,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,WAAW,GAAG,KAAK;QAC7B,IAAI,IAAI,CAAC,MAAM;YAAE,OAAO;QACxB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QAEnB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,OAAO;SACR;QAED,IAAI,CAAC,WAAW,EAAE;YAChB,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE;gBAC7B,OAAO,EAAE,IAAI,CAAC,QAAQ;aACvB,CAAC,CAAC;SACJ;QAED,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC;QACnB,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;QAEpC,IAAI,IAAI,CAAC,YAAY,IAAI,SAAS,EAAE;YAClC,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YACjC,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;SAC/B;QAED,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;QACzB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;IACjB,CAAC;IAED,OAAO,CAAC,IAAY;QAClB,IAAI,KAAK,GAAG,CAAC,CAAC;QAEd,IAAI;QACJ,MAAM,YAAY,GAAG,IAAI,CAAC;QAC1B,IAAI;QACJ,MAAM,iBAAiB,GAAG,IAAI,CAAC;QAC/B,KAAK;QACL,MAAM,IAAI,GAAG,EAAE,CAAC;QAEhB,OAAO,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE;YAC1B,0BAA0B;YAC1B,IACE,IAAI,CAAC,SAAS,IAAI,UAAU,CAAC,SAAS;gBACtC,IAAI,CAAC,KAAK,CAAC,IAAI,YAAY,EAC3B;gBACA,IAAI,CAAC,YAAY,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBAClC,KAAK,EAAE,CAAC;gBAER,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,uBAAuB,CAAC;aACrD;iBAAM,IAAI,IAAI,CAAC,SAAS,IAAI,UAAU,CAAC,uBAAuB,EAAE;gBAC/D,6CAA6C;gBAC7C,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBACpC,KAAK,EAAE,CAAC;gBAER,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,IAAI,CAAC,EAAE;oBACjC,IAAI,CAAC,gBAAgB;wBACnB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;oBAErD,IAAI,IAAI,CAAC,gBAAgB,GAAG,CAAC,EAAE;wBAC7B,IAAI,CAAC,UAAU,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;wBACpD,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;wBAC3B,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,kBAAkB,CAAC;qBAChD;yBAAM;wBACL,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;qBACvC;iBACF;aACF;iBAAM,IAAI,IAAI,CAAC,SAAS,IAAI,UAAU,CAAC,kBAAkB,EAAE;gBAC1D,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;gBACxD,KAAK,EAAE,CAAC;gBAER,IAAI,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,gBAAgB,EAAE;oBACnD,MAAM,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;oBAC3C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE;wBAChC,cAAc;wBACd,MAAM,MAAM,GAAG,IAAA,qBAAc,EAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBAC/C,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,aAAa,EAAE,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;qBAC1D;oBACD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE;wBAChC,aAAa;wBACb,MAAM,MAAM,GAAG,IAAA,sBAAe,EAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBAChD,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE,aAAa,EAAE,MAAM,CAAC,CAAC;wBAChD,MAAM,eAAe,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;wBACpD,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,eAAe,CAAC,CAAC;qBAC3D;oBACD,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;iBACvC;gBACD,qBAAqB;aACtB;iBAAM,IACL,IAAI,CAAC,SAAS,IAAI,UAAU,CAAC,SAAS;gBACtC,IAAI,CAAC,KAAK,CAAC,IAAI,iBAAiB,EAChC;gBACA,yCAAyC;gBACzC,IAAI,CAAC,YAAY,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBAClC,KAAK,EAAE,CAAC;gBAER,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,mBAAmB,CAAC;aACjD;iBAAM,IAAI,IAAI,CAAC,SAAS,IAAI,UAAU,CAAC,mBAAmB,EAAE;gBAC3D,0BAA0B;gBAE1B,oCAAoC;gBACpC,kCAAkC;gBAClC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE;oBACrB,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;iBACrC;gBACD,KAAK,EAAE,CAAC;gBAER,8EAA8E;gBAC9E,6EAA6E;gBAC7E,IACE,IAAI,CAAC,YAAY,CAAC,MAAM,IAAI,CAAC;oBAC7B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI;oBACvD,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,IAAI,EACvD;oBACA,mBAAmB;oBAEnB,MAAM,IAAI,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAChE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBAE/B,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;oBAC3B,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;oBAC/B,IAAI,CAAC,WAAW,GAAG,EAAE,CAAC;oBAEtB,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;wBACrB,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;wBAElC,IAAI,OAAO,KAAK,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;4BAC/B,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,IAAI,EAAE,CAAC;4BAC9C,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;4BAEhD,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;gCACnB,GAAG,IAAI,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;oCACxC,CAAC,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC;oCACpB,CAAC,CAAC,IAAI,CAAC;4BAEX,yGAAyG;4BACzG,IAAI,GAAG,CAAC,WAAW,EAAE,IAAI,gBAAgB,EAAE;gCACzC,IAAI,CAAC,iBAAiB,GAAG,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;6BAC7C;yBACF;oBACH,CAAC,CAAC,CAAC;oBAEH,uDAAuD;oBACvD,mBAAmB;oBACnB,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;wBAC3B,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;wBAE/B,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;wBACjE,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;qBACvC;yBAAM;wBACL,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;wBACvB,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,oBAAoB,CAAC;qBAClD;iBACF;aACF;iBAAM,IACL,IAAI,CAAC,SAAS,IAAI,UAAU,CAAC,oBAAoB;gBACjD,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,IAAI,CAAC,iBAAiB,EACjD;gBACA,kCAAkC;gBAClC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBACpC,KAAK,EAAE,CAAC;gBAER,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,IAAI,IAAI,CAAC,iBAAiB,EAAE;oBACtD,MAAM,IAAI,GAAG,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;oBAChE,MAAM,YAAY,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBAEtC,wBAAwB;oBACxB,IAAI,CAAC,IAAI,CACP,KAAK,EACL,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,GAAG,IAAI,EACzD,MAAM,CACP,CAAC;oBAEF,IAAI,CAAC,IAAI,CACP,UAAU,EACV,IAAI,CAAC,cAAc,EACnB,IAAI,CAAC,WAAW,EAChB,YAAY,CACb,CAAC;oBACF,IAAI,CAAC,SAAS,GAAG,UAAU,CAAC,SAAS,CAAC;iBACvC;aACF;iBAAM;gBACL,kBAAkB;gBAClB,MAAM,IAAI,KAAK,CACb,iFAAiF,CAClF,CAAC;aACH;SACF,CAAC,YAAY;IAChB,CAAC;IAED,oBAAoB,CAAC,OAAe,EAAE,MAAc;QAClD,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,OAAO;SACR;QAED,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,MAAM,yCAAyC,OAAO,EAAE,CAAC;QAC/E,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;QAE9B,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC;QAC7B,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,UAAU;QAC5B,MAAM,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;QACpB,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;QACxC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;QAExC,MAAM,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;QAC7C,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAED,YAAY,CAAC,IAAY,EAAE,IAAY,EAAE,MAAc;QACrD,MAAM,GAAG,GAAG,KAAK,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QACvC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE;YAC5D,6BAA6B;YAC7B,GAAG,CAAC,KAAK,EAAE,CAAC;QACd,CAAC,CAAC,CAAC;IACL,CAAC;IAED,oBAAoB;QAClB,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC;QAC7B,MAAM,OAAO,GAAG,CAAC,CAAC;QAClB,MAAM,UAAU,GAAG,CAAC,CAAC;QACrB,MAAM,WAAW,GAAG,CAAC,CAAC,CAAC,kBAAkB;QACzC,MAAM,UAAU,GAAG,GAAG,CAAC,CAAC,kBAAkB;QAC1C,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,2BAA2B;QACjE,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,UAAU,IAAI,CAAC,CAAC,GAAG,WAAW,CAAC;QAC7D,MAAM,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC;QACvB,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;QACjC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;QACjC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC;QAC3C,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC;QAC3C,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;QAC1C,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC;QAE1C,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,YAAY,CAAC,MAAkB,EAAE,IAAY;QACjD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YACrC,UAAU,CAAC,GAAG,EAAE;gBACd,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,KAAU,EAAE,EAAE;oBAChC,IAAI,KAAK,EAAE;wBACT,MAAM,CAAC,KAAK,CAAC,CAAC;qBACf;yBAAM;wBACL,OAAO,CAAC,SAAS,CAAC,CAAC;qBACpB;gBACH,CAAC,CAAC,CAAA;YACJ,CAAC,EAAE,EAAE,CAAC,CAAC;QACT,CAAC,CAAC,CAAA;IACJ,CAAC;CACF;AA3zBD,6BA2zBC","sourcesContent":["import * as net from \"net\";\r\nimport * as dgram from \"dgram\";\r\nimport { parse as urlParse } from \"url\";\r\nimport { EventEmitter } from \"events\";\r\n\r\nimport {\r\n  parseRTPPacket,\r\n  parseRTCPPacket,\r\n  getMD5Hash,\r\n  Transport,\r\n  parseTransport,\r\n  generateSSRC,\r\n} from \"./util\";\r\n\r\nimport * as transform from \"sdp-transform\";\r\nimport RTPPacket from \"./transports/RTPPacket\";\r\nconst RTP_AVP = \"RTP/AVP\";\r\n\r\nconst STATUS_OK = 200;\r\nconst STATUS_UNAUTH = 401;\r\n\r\n// The WWW_AUTH is of the format\r\n//      TOKEN key=value\r\n//      TOKEN key1=value1,key2=value2\r\n//      TOKEN key1=\"value1\",key2=value2\r\n\r\n// RegEx reminder ? = Zero or One item\r\n//                * = Zero or More items\r\n//                + = 1 or More items\r\n//                \\s is whitespace. But we need to 'escape the slash', hence \\\\s (or put the regex in / / characters)\r\n//                ?= is a lookahead\r\n\r\n// The RegEx has two 'Groups'\r\n//      \r\n// Group 1 (finding the Key)\r\n//    Look for one or more characters (a..z or A..Z)\r\n//    then look for whitespace\r\n//    then look for 'equals'\r\n//    then look for whitespace\r\n//    then look for an optional Quote character\r\n//\r\n// Group 2 (finding the Value) -\r\n//    Look for EITHER 'look backwards for a Quote', some characters, 'lookahead for a Quote'\r\n//                 OR some characters until (by looking ahead) you can see that another key comes next. The lookahead is 'optinal whitespace' 'comma' 'optional whitespace' 'chars' 'optinal whitespace' 'equals'\r\n//                 OR some characters followed by 'optinal whitespace'\r\n\r\nconst WWW_AUTH = \"WWW-Authenticate\";\r\nconst WWW_AUTH_REGEX = new RegExp('([a-zA-Z]+)\\\\s*=\\\\s*\"?((?<=\").*?(?=\")|.*?(?=\\\\s*,?\\\\s*[a-zA-Z]+\\\\s*=)|.+[^\\\\s])', \"g\");\r\n\r\nenum ReadStates {\r\n  SEARCHING,\r\n  READING_RTSP_HEADER,\r\n  READING_RTSP_PAYLOAD,\r\n  READING_RAW_PACKET_SIZE,\r\n  READING_RAW_PACKET,\r\n}\r\n\r\ntype Connection = \"udp\" | \"tcp\";\r\n\r\ntype Headers = {\r\n  [key: string]: string | number | undefined;\r\n  Session?: string;\r\n  Location?: string;\r\n  CSeq?: number;\r\n  \"WWW-Authenticate\"?: string;\r\n  Transport?: string;\r\n  Unsupported?: string;\r\n};\r\n\r\ntype Detail = {\r\n  codec: string;\r\n  mediaSource: ({ // cannot work out how to pull this type in\r\n                type: string;\r\n                port: number;\r\n                protocol: string;\r\n                payloads?: string | undefined;\r\n                } & transform.MediaDescription); // get Type from the interface\r\n  transport: Transport['parameters']; // get Type from the interface\r\n  isH264: boolean; // legacy API\r\n  rtpChannel: number;\r\n  rtcpChannel: number;\r\n};\r\n\r\nexport default class RTSPClient extends EventEmitter {\r\n  username: string;\r\n  password: string;\r\n  headers: { [key: string]: string };\r\n\r\n  isConnected = false;\r\n  closed = false;\r\n\r\n  // These are all set in #connect or #_netConnect.\r\n\r\n  _url?: string;\r\n  _client?: net.Socket;\r\n  _cSeq = 0;\r\n  _unsupportedExtensions?: string[];\r\n  // Example: 'SessionId'[';timeout=seconds']\r\n  _session?: string;\r\n  _keepAliveID?: NodeJS.Timeout;\r\n  _nextFreeInterleavedChannel = 0;\r\n  _nextFreeUDPPort = 5000;\r\n\r\n  readState: ReadStates = ReadStates.SEARCHING;\r\n\r\n  // Used as a cache for the data stream.\r\n  // What's in here is based on current #readState.\r\n  messageBytes: number[] = [];\r\n\r\n  // Used for parsing RTSP responses,\r\n\r\n  // Content-Length header in the RTSP message.\r\n  rtspContentLength = 0;\r\n  rtspStatusLine = \"\";\r\n  rtspHeaders: Headers = {};\r\n\r\n  // Used for parsing RTP/RTCP responses.\r\n\r\n  rtspPacketLength = 0;\r\n  rtspPacket: Buffer = new Buffer(\"\");\r\n  rtspPacketPointer = 0;\r\n\r\n  // Used in #_emptyReceiverReport.\r\n  clientSSRC = generateSSRC();\r\n\r\n  tcpSocket: net.Socket = new net.Socket();\r\n  setupResult: Array<Detail> = [];\r\n  constructor(\r\n    username: string,\r\n    password: string,\r\n    headers?: { [key: string]: string }\r\n  ) {\r\n    super();\r\n\r\n    this.username = username;\r\n    this.password = password;\r\n    this.headers = {\r\n      ...(headers || {}),\r\n      \"User-Agent\": \"yellowstone/3.x\",\r\n    };\r\n  }\r\n\r\n  // This manages the lifecycle for the RTSP connection\r\n  // over TCP.\r\n  //\r\n  // Sets #_client.\r\n  //\r\n  // Handles receiving data & closing port, called during\r\n  // #connect.\r\n  _netConnect(hostname: string, port: number): Promise<this> {\r\n    return new Promise((resolve, reject) => {\r\n      // Set after listeners defined.\r\n\r\n      const errorListener = (err: any) => {\r\n        client.removeListener(\"error\", errorListener);\r\n        reject(err);\r\n      };\r\n\r\n      const closeListener = () => {\r\n        client.removeListener(\"close\", closeListener);\r\n        this.close(true);\r\n      };\r\n\r\n      const responseListener = (responseName: string, headers: Headers) => {\r\n        const name = responseName.split(\" \")[0];\r\n\r\n        if (name.indexOf(\"RTSP/\") === 0) {\r\n          return;\r\n        }\r\n\r\n        if (name === \"REDIRECT\" || name === \"ANNOUNCE\") {\r\n          this.respond(\"200 OK\", { CSeq: headers.CSeq });\r\n        }\r\n\r\n        if (name === \"REDIRECT\" && headers.Location) {\r\n          this.close();\r\n          this.connect(headers.Location);\r\n        }\r\n      };\r\n\r\n      const client = net.connect(port, hostname, () => {\r\n        this.isConnected = true;\r\n        this._client = client;\r\n\r\n        client.removeListener(\"error\", errorListener);\r\n\r\n        this.on(\"response\", responseListener);\r\n        resolve(this);\r\n      });\r\n\r\n      client.on(\"data\", this._onData.bind(this));\r\n      client.on(\"error\", errorListener);\r\n      client.on(\"close\", closeListener);\r\n      this.tcpSocket = client;\r\n    });\r\n  }\r\n\r\n  async connect(\r\n    url: string,\r\n    {\r\n      keepAlive = true,\r\n      connection = \"udp\",\r\n    }: { keepAlive: boolean; connection?: Connection } = {\r\n        keepAlive: true,\r\n        connection: \"udp\",\r\n      }\r\n  ): Promise<Detail[]> {\r\n    const { hostname, port } = urlParse((this._url = url));\r\n    if (!hostname) {\r\n      throw new Error(\"URL parsing error in connect method.\");\r\n    }\r\n\r\n    const details: Detail[] = [];\r\n\r\n    await this._netConnect(hostname, parseInt(port || \"554\"));\r\n    await this.request(\"OPTIONS\");\r\n\r\n    const describeRes = await this.request(\"DESCRIBE\", {\r\n      Accept: \"application/sdp\",\r\n    });\r\n    if (!describeRes || !describeRes.mediaHeaders) {\r\n      throw new Error(\r\n        \"No media headers on DESCRIBE; RTSP server is broken (sanity check)\"\r\n      );\r\n    }\r\n\r\n    // For now, only RTP/AVP is supported.\r\n    const { media } = transform.parse(describeRes.mediaHeaders.join(\"\\r\\n\"));\r\n\r\n    // Loop over the Media Streams in the SDP looking for Video or Audio\r\n    // In theory the SDP can contain multiple Video and Audio Streams. We only want one of each type\r\n    let hasVideo = false;\r\n    let hasAudio = false;\r\n    let hasMetaData = false;\r\n    let hasBackchannel = false;\r\n\r\n    for (let x = 0; x < media.length; x++) {\r\n      let needSetup = false;\r\n      let codec = \"\";\r\n      const mediaSource = media[x];\r\n\r\n\r\n      // RFC says \"If none of the direction attributes (\"sendonly\", \"recvonly\", \"inactive\", and \"sendrecv\") are present,\r\n      // the \"sendrecv\" SHOULD be assumed\r\n      if (mediaSource.direction == undefined) mediaSource.direction = \"sendrecv\"; //  Wowza does not send 'direction'\r\n\r\n      if (\r\n        mediaSource.type === \"video\" &&\r\n        mediaSource.protocol === RTP_AVP &&\r\n        mediaSource.rtp[0].codec === \"H264\"\r\n      ) {\r\n        this.emit(\"log\", \"H264 Video Stream Found in SDP\", \"\");\r\n        if (hasVideo == false) {\r\n          needSetup = true;\r\n          hasVideo = true;\r\n          codec = \"H264\";\r\n        }\r\n      }\r\n\r\n      if (\r\n        mediaSource.type === \"video\" &&\r\n        mediaSource.protocol === RTP_AVP &&\r\n        mediaSource.rtp[0].codec === \"H265\"\r\n      ) {\r\n        this.emit(\"log\", \"H265 Video Stream Found in SDP\", \"\");\r\n        if (hasVideo == false) {\r\n          needSetup = true;\r\n          hasVideo = true;\r\n          codec = \"H265\";\r\n        }\r\n      }\r\n\r\n\r\n      if (\r\n        mediaSource.type === \"audio\" &&\r\n        (mediaSource.direction === \"recvonly\" || mediaSource.direction === \"sendrecv\") &&\r\n        mediaSource.protocol === RTP_AVP &&\r\n        mediaSource.rtp[0].codec.toLowerCase() === \"mpeg4-generic\" && // (RFC examples are lower case. Axis cameras use upper case)\r\n        mediaSource.fmtp[0].config.includes(\"AAC\")\r\n      ) {\r\n        this.emit(\"log\", \"AAC Audio Stream Found in SDP\", \"\");\r\n        if (hasAudio == false) {\r\n          needSetup = true;\r\n          hasAudio = true;\r\n          codec = \"AAC\";\r\n        }\r\n      }\r\n\r\n      if (mediaSource.type === \"audio\" &&\r\n        mediaSource.direction === \"sendonly\" &&\r\n        mediaSource.protocol === RTP_AVP) {\r\n        this.emit(\"log\", \"Audio backchannel Found in SDP\", \"\");\r\n        if (hasBackchannel == false) {\r\n          needSetup = true;\r\n          hasBackchannel = true;\r\n          codec = mediaSource.rtp[0].codec;\r\n        }\r\n      }\r\n\r\n      if (\r\n        mediaSource.type === \"application\" &&\r\n        mediaSource.protocol === RTP_AVP &&\r\n        mediaSource.rtp[0].codec.toLowerCase() === \"vnd.onvif.metadata\"\r\n      ) {\r\n        this.emit(\"log\", \"ONVIF Meta Data Found in SDP\", \"\");\r\n        if (hasMetaData == false) {\r\n          needSetup = true;\r\n          hasMetaData = true;\r\n          codec = \"vnd.onvif.metadata\";\r\n        }\r\n      }\r\n\r\n      if (needSetup) {\r\n        let streamurl = \"\";\r\n        // The 'control' in the SDP can be a relative or absolute uri\r\n        if (mediaSource.control) {\r\n          if (mediaSource.control.toLowerCase().startsWith(\"rtsp://\")) {\r\n            // absolute path\r\n            streamurl = mediaSource.control;\r\n          } else {\r\n            // relative path\r\n            streamurl = this._url + \"/\" + mediaSource.control;\r\n          }\r\n        }\r\n\r\n        // Perform a SETUP on the streamurl\r\n        // either 'udp' RTP/RTCP packets\r\n        // or with 'tcp' RTP/TCP packets which are interleaved into the TCP based RTSP socket\r\n        let setupRes;\r\n        let rtpChannel;\r\n        let rtcpChannel;\r\n        let rtpReceiver: dgram.Socket|null = null; // UDP mode init value\r\n        let rtcpReceiver: dgram.Socket|null = null; // UDP mode init value\r\n\r\n        if (connection === \"udp\") {\r\n          // Create a pair of UDP listeners, even numbered port for RTP\r\n          // and odd numbered port for RTCP\r\n\r\n          rtpChannel = this._nextFreeUDPPort;\r\n          rtcpChannel = this._nextFreeUDPPort + 1;\r\n          this._nextFreeUDPPort += 2;\r\n\r\n          const rtpPort = rtpChannel;\r\n          rtpReceiver = dgram.createSocket(\"udp4\");\r\n\r\n          rtpReceiver.on(\"message\", (buf, remote) => {\r\n            const packet = parseRTPPacket(buf);\r\n            this.emit(\"data\", rtpPort, packet.payload, packet);\r\n          });\r\n\r\n          const rtcpPort = rtcpChannel;\r\n          rtcpReceiver = dgram.createSocket(\"udp4\");\r\n\r\n          rtcpReceiver.on(\"message\", (buf, remote) => {\r\n            const packet = parseRTCPPacket(buf);\r\n            this.emit(\"controlData\", rtcpPort, packet);\r\n\r\n            const receiver_report = this._emptyReceiverReport();\r\n            this._sendUDPData(remote.address, remote.port, receiver_report);\r\n          });\r\n\r\n          // Block until both UDP sockets are open.\r\n\r\n          await new Promise((resolve) => {\r\n            rtpReceiver?.bind(rtpPort, () => resolve({}));\r\n          });\r\n\r\n          await new Promise((resolve) => {\r\n            rtcpReceiver?.bind(rtcpPort, () => resolve({}));\r\n          });\r\n\r\n          const setupHeader = {\r\n            Transport: `RTP/AVP;unicast;client_port=${rtpPort}-${rtcpPort}`,\r\n          };\r\n          if (this._session)\r\n            Object.assign(setupHeader, { Session: this._session });\r\n          setupRes = await this.request(\"SETUP\", setupHeader, streamurl);\r\n        } else if (connection === \"tcp\") {\r\n          // channel 0, RTP\r\n          // channel 1, RTCP\r\n\r\n          rtpChannel = this._nextFreeInterleavedChannel;\r\n          rtcpChannel = this._nextFreeInterleavedChannel + 1;\r\n          this._nextFreeInterleavedChannel += 2;\r\n\r\n          const setupHeader = {\r\n            Transport: `RTP/AVP/TCP;interleaved=${rtpChannel}-${rtcpChannel}`,\r\n          };\r\n          if (this._session)\r\n            Object.assign(setupHeader, { Session: this._session }); // not used on first SETUP\r\n          setupRes = await this.request(\"SETUP\", setupHeader, streamurl);\r\n        } else {\r\n          throw new Error(\r\n            `Connection parameter to RTSPClient#connect is ${connection}, not udp or tcp!`\r\n          );\r\n        }\r\n\r\n        if (!setupRes) {\r\n          throw new Error(\r\n            \"No SETUP response; RTSP server is broken (sanity check)\"\r\n          );\r\n        }\r\n\r\n        const { headers } = setupRes;\r\n\r\n        if (!headers.Transport) {\r\n          throw new Error(\r\n            \"No Transport header on SETUP; RTSP server is broken (sanity check)\"\r\n          );\r\n        }\r\n\r\n        const transport = parseTransport(headers.Transport);\r\n        if (\r\n          transport.protocol !== \"RTP/AVP/TCP\" &&\r\n          transport.protocol !== \"RTP/AVP\"\r\n        ) {\r\n          throw new Error(\r\n            \"Only RTSP servers supporting RTP/AVP(unicast) or RTP/ACP/TCP are supported at this time.\"\r\n          );\r\n        }\r\n\r\n        // Patch from zoolyka (Zoltan Hajdu).\r\n        // Try to open a hole in the NAT router (to allow incoming UDP packets)\r\n        // by send a UDP packet for RTP and RTCP to the remote RTSP server.\r\n        // Note, Roger did not have a router that needed this so the feature is untested.\r\n        // May be better to change the RTCP message to a Receiver Report, leaving the RTP message as zero bytes\r\n        if (connection === \"udp\" && transport && rtpReceiver && rtcpReceiver) {\r\n          rtpReceiver.send(Buffer.from(''), Number(transport.parameters[\"server_port\"].split(\"-\")[0]), hostname);\r\n          rtcpReceiver.send(Buffer.from(''), Number(transport.parameters[\"server_port\"].split(\"-\")[1]), hostname);\r\n        }\r\n\r\n        if (headers.Unsupported) {\r\n          this._unsupportedExtensions = headers.Unsupported.split(\",\");\r\n        }\r\n\r\n        if (headers.Session) {\r\n          this._session = headers.Session.split(\";\")[0];\r\n        }\r\n\r\n        const detail: Detail = {\r\n          codec,\r\n          mediaSource,\r\n          transport: transport.parameters,\r\n          isH264: codec === \"H264\",\r\n          rtpChannel,\r\n          rtcpChannel,\r\n        };\r\n\r\n        details.push(detail);\r\n      } // end if (needSetup)\r\n    } // end for loop, looping over each media stream\r\n\r\n    if (keepAlive) {\r\n      // Start a Timer to send OPTIONS every 20 seconds to keep stream alive\r\n      // using the Session ID\r\n      this._keepAliveID = setInterval(() => {\r\n        this.request(\"OPTIONS\", { Session: this._session });\r\n        //        this.request(\"OPTIONS\");\r\n      }, 20 * 1000);\r\n    }\r\n\r\n    this.setupResult = details;\r\n    return details;\r\n  }\r\n\r\n  request(\r\n    requestName: string,\r\n    headersParam: Headers = {},\r\n    url?: string\r\n  ): Promise<{ headers: Headers; mediaHeaders?: string[] } | void> {\r\n    if (!this._client) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const id = ++this._cSeq;\r\n    // mutable via string addition\r\n    let req = `${requestName} ${url || this._url} RTSP/1.0\\r\\nCSeq: ${id}\\r\\n`;\r\n\r\n    const headers = {\r\n      ...this.headers,\r\n      ...headersParam,\r\n    };\r\n\r\n    // NOTE:\r\n    // If we cache the Authenitcation Type (Direct or Basic) then we could\r\n    // re-compute an Authorization Header here and include in the RTSP Command\r\n    // This would make connections a faster with fewer round-trips to the RTSP Server\r\n\r\n    req += Object.entries(headers)\r\n      .map(([key, value]) => `${key}: ${value}\\r\\n`)\r\n      .join(\"\");\r\n\r\n    this.emit(\"log\", req, \"C->S\");\r\n    // Make sure to add an empty line after the request.\r\n    this._client.write(`${req}\\r\\n`);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const responseHandler = (\r\n        responseName: string,\r\n        resHeaders: Headers,\r\n        mediaHeaders: string[]\r\n      ) => {\r\n        const firstAnswer: string = String(resHeaders[\"\"]) || \"\";\r\n        if (firstAnswer.indexOf(\"401\") >= 0 && 'Authorization' in headers) {\r\n          // If the RTSP Command we sent included an Authorization and we have 401 error, then reject()\r\n          reject(new Error(`Bad RTSP credentials!`));\r\n          return;\r\n        }\r\n        if (resHeaders.CSeq !== id) {\r\n          return;\r\n        }\r\n\r\n        this.removeListener(\"response\", responseHandler);\r\n\r\n        const statusCode = parseInt(responseName.split(\" \")[1]);\r\n\r\n        if (statusCode === STATUS_OK) {\r\n          if (mediaHeaders.length > 0) {\r\n            resolve({\r\n              headers: resHeaders,\r\n              mediaHeaders,\r\n            });\r\n          } else {\r\n            resolve({\r\n              headers: resHeaders,\r\n            });\r\n          }\r\n        } else {\r\n          const authHeader = resHeaders[WWW_AUTH];\r\n\r\n          // We have status code unauthenticated.\r\n          if (statusCode === STATUS_UNAUTH && authHeader) {\r\n            const type = authHeader.split(\" \")[0];\r\n\r\n            // Get auth properties from WWW_AUTH header.\r\n            let realm = \"\";\r\n            let nonce = \"\";\r\n\r\n            let match = WWW_AUTH_REGEX.exec(authHeader);\r\n            while (match != null) {\r\n              const prop = match[1];\r\n\r\n              if (prop == \"realm\" && match[2]) {\r\n                realm = match[2];\r\n              }\r\n\r\n              if (prop == \"nonce\" && match[2]) {\r\n                nonce = match[2];\r\n              }\r\n\r\n              match = WWW_AUTH_REGEX.exec(authHeader);\r\n            }\r\n\r\n            // mutable, corresponds to Authorization header\r\n            let authString = \"\";\r\n\r\n            if (type === \"Digest\") {\r\n              // Digest Authentication\r\n\r\n              const ha1 = getMD5Hash(\r\n                `${this.username}:${realm}:${this.password}`\r\n              );\r\n              const ha2 = getMD5Hash(`${requestName}:${this._url}`);\r\n              const ha3 = getMD5Hash(`${ha1}:${nonce}:${ha2}`);\r\n\r\n              authString = `Digest username=\"${this.username}\",realm=\"${realm}\",nonce=\"${nonce}\",uri=\"${this._url}\",response=\"${ha3}\"`;\r\n            } else if (type === \"Basic\") {\r\n              // Basic Authentication\r\n              // https://xkcd.com/538/\r\n              const b64 = new Buffer(\r\n                `${this.username}:${this.password}`\r\n              ).toString(\"base64\");\r\n              authString = `Basic ${b64}`;\r\n            }\r\n\r\n            Object.assign(headers, {\r\n              Authorization: authString,\r\n            });\r\n\r\n            resolve(this.request(requestName, headers, url)); // Call this.request with Authorized request\r\n            return;\r\n          }\r\n\r\n          reject(new Error(`Bad RTSP status code ${statusCode}!`));\r\n          return;\r\n        }\r\n      };\r\n\r\n      this.on(\"response\", responseHandler);\r\n    });\r\n  }\r\n\r\n  respond(status: string, headersParam: Headers = {}): void {\r\n    if (!this._client) {\r\n      return;\r\n    }\r\n\r\n    // mutable via string addition\r\n    let res = `RTSP/1.0 ${status}\\r\\n`;\r\n\r\n    const headers = {\r\n      ...this.headers,\r\n      ...headersParam,\r\n    };\r\n\r\n    res += Object.entries(headers)\r\n      .map(([key, value]) => `${key}: ${value}\\r\\n`)\r\n      .join(\"\");\r\n\r\n    this.emit(\"log\", res, \"C->S\");\r\n    this._client.write(`${res}\\r\\n`);\r\n  }\r\n\r\n  async play(): Promise<void> {\r\n    if (!this.isConnected) {\r\n      throw new Error(\"Client is not connected.\");\r\n    }\r\n\r\n    await this.request(\"PLAY\", { Session: this._session });\r\n  }\r\n\r\n  async pause(): Promise<void> {\r\n    if (!this.isConnected) {\r\n      throw new Error(\"Client is not connected.\");\r\n    }\r\n\r\n    await this.request(\"PAUSE\", { Session: this._session });\r\n  }\r\n\r\n  async sendAudioBackChannel(audioChunk: Buffer): Promise<void> {\r\n    let rtp, buf;\r\n    const bufSize = 160;\r\n    while (audioChunk.length > 0) {\r\n      if (audioChunk.length > bufSize) {\r\n        buf = audioChunk.slice(0, bufSize);\r\n        audioChunk = audioChunk.slice(bufSize, audioChunk.length);\r\n      } else {\r\n        buf = audioChunk.slice(0, audioChunk.length);\r\n        audioChunk = Buffer.from([]);\r\n      }\r\n      if (!rtp)\r\n        rtp = new RTPPacket(buf);\r\n      else\r\n        rtp.payload = buf;\r\n      // rtp.type = 8;// set động\r\n      rtp.time += buf.length;\r\n      rtp.seq++;\r\n      const bufferLength = Buffer.alloc(2);\r\n      bufferLength.writeUInt16BE(rtp.packet.length, 0);\r\n      let channelInterleaved = this.setupResult.filter((value) => {\r\n        return value.mediaSource.type === 'audio' && value.mediaSource.direction === 'sendonly';\r\n      })[0].transport.interleaved;\r\n      /* RTSP Interleaved Frame structure\r\n      |dollar sign|channel identifier|data length|\r\n      |1 Byte     |1 Byte            |2 Bytes    |\r\n      */\r\n      channelInterleaved = channelInterleaved.split('-')[0];\r\n      let interleavedHeader = Buffer.from([0x24]);// set '$'\r\n      interleavedHeader = Buffer.concat([interleavedHeader, Buffer.from([channelInterleaved])]);\r\n      interleavedHeader = Buffer.concat([interleavedHeader, bufferLength]);\r\n      const dataToSend = Buffer.concat([interleavedHeader, rtp.packet]);\r\n      await this._socketWrite(this.tcpSocket, dataToSend);\r\n    }\r\n    return;\r\n  }\r\n\r\n  async close(isImmediate = false): Promise<void> {\r\n    if (this.closed) return;\r\n    this.closed = true;\r\n\r\n    if (!this._client) {\r\n      return;\r\n    }\r\n    \r\n    if (!isImmediate) {\r\n      await this.request(\"TEARDOWN\", {\r\n        Session: this._session,\r\n      });\r\n    }\r\n\r\n    this._client.end();\r\n    this.removeAllListeners(\"response\");\r\n\r\n    if (this._keepAliveID != undefined) {\r\n      clearInterval(this._keepAliveID);\r\n      this._keepAliveID = undefined;\r\n    }\r\n\r\n    this.isConnected = false;\r\n    this._cSeq = 0;\r\n  }\r\n\r\n  _onData(data: Buffer): void {\r\n    let index = 0;\r\n\r\n    // $\r\n    const PACKET_START = 0x24;\r\n    // R\r\n    const RTSP_HEADER_START = 0x52;\r\n    // /n\r\n    const ENDL = 10;\r\n\r\n    while (index < data.length) {\r\n      // read RTP or RTCP packet\r\n      if (\r\n        this.readState == ReadStates.SEARCHING &&\r\n        data[index] == PACKET_START\r\n      ) {\r\n        this.messageBytes = [data[index]];\r\n        index++;\r\n\r\n        this.readState = ReadStates.READING_RAW_PACKET_SIZE;\r\n      } else if (this.readState == ReadStates.READING_RAW_PACKET_SIZE) {\r\n        // accumulate bytes for $, channel and length\r\n        this.messageBytes.push(data[index]);\r\n        index++;\r\n\r\n        if (this.messageBytes.length == 4) {\r\n          this.rtspPacketLength =\r\n            (this.messageBytes[2] << 8) + this.messageBytes[3];\r\n\r\n          if (this.rtspPacketLength > 0) {\r\n            this.rtspPacket = new Buffer(this.rtspPacketLength);\r\n            this.rtspPacketPointer = 0;\r\n            this.readState = ReadStates.READING_RAW_PACKET;\r\n          } else {\r\n            this.readState = ReadStates.SEARCHING;\r\n          }\r\n        }\r\n      } else if (this.readState == ReadStates.READING_RAW_PACKET) {\r\n        this.rtspPacket[this.rtspPacketPointer++] = data[index];\r\n        index++;\r\n\r\n        if (this.rtspPacketPointer == this.rtspPacketLength) {\r\n          const packetChannel = this.messageBytes[1];\r\n          if ((packetChannel & 0x01) === 0) {\r\n            // even number\r\n            const packet = parseRTPPacket(this.rtspPacket);\r\n            this.emit(\"data\", packetChannel, packet.payload, packet);\r\n          }\r\n          if ((packetChannel & 0x01) === 1) {\r\n            // odd number\r\n            const packet = parseRTCPPacket(this.rtspPacket);\r\n            this.emit(\"controlData\", packetChannel, packet);\r\n            const receiver_report = this._emptyReceiverReport();\r\n            this._sendInterleavedData(packetChannel, receiver_report);\r\n          }\r\n          this.readState = ReadStates.SEARCHING;\r\n        }\r\n        // read response data\r\n      } else if (\r\n        this.readState == ReadStates.SEARCHING &&\r\n        data[index] == RTSP_HEADER_START\r\n      ) {\r\n        // found the start of a RTSP rtsp_message\r\n        this.messageBytes = [data[index]];\r\n        index++;\r\n\r\n        this.readState = ReadStates.READING_RTSP_HEADER;\r\n      } else if (this.readState == ReadStates.READING_RTSP_HEADER) {\r\n        // Reading a RTSP message.\r\n\r\n        // Add character to the messageBytes\r\n        // Ignore /r (13) but keep /n (10)\r\n        if (data[index] != 13) {\r\n          this.messageBytes.push(data[index]);\r\n        }\r\n        index++;\r\n\r\n        // if we have two new lines back to back then we have a complete RTSP command,\r\n        // note we may still need to read the Content Payload (the body) e.g. the SDP\r\n        if (\r\n          this.messageBytes.length >= 2 &&\r\n          this.messageBytes[this.messageBytes.length - 2] == ENDL &&\r\n          this.messageBytes[this.messageBytes.length - 1] == ENDL\r\n        ) {\r\n          // Parse the Header\r\n\r\n          const text = String.fromCharCode.apply(null, this.messageBytes);\r\n          const lines = text.split(\"\\n\");\r\n\r\n          this.rtspContentLength = 0;\r\n          this.rtspStatusLine = lines[0];\r\n          this.rtspHeaders = {};\r\n\r\n          lines.forEach((line) => {\r\n            const indexOf = line.indexOf(\":\");\r\n\r\n            if (indexOf !== line.length - 1) {\r\n              const key = line.substring(0, indexOf).trim();\r\n              const data = line.substring(indexOf + 1).trim();\r\n\r\n              this.rtspHeaders[key] =\r\n                key != \"Session\" && data.match(/^[0-9]+$/)\r\n                  ? parseInt(data, 10)\r\n                  : data;\r\n\r\n              // workaround for buggy Hipcam RealServer/V1.0 camera which returns Content-length and not Content-Length\r\n              if (key.toLowerCase() == \"content-length\") {\r\n                this.rtspContentLength = parseInt(data, 10);\r\n              }\r\n            }\r\n          });\r\n\r\n          // if no content length, there there's no media headers\r\n          // emit the message\r\n          if (!this.rtspContentLength) {\r\n            this.emit(\"log\", text, \"S->C\");\r\n\r\n            this.emit(\"response\", this.rtspStatusLine, this.rtspHeaders, []);\r\n            this.readState = ReadStates.SEARCHING;\r\n          } else {\r\n            this.messageBytes = [];\r\n            this.readState = ReadStates.READING_RTSP_PAYLOAD;\r\n          }\r\n        }\r\n      } else if (\r\n        this.readState == ReadStates.READING_RTSP_PAYLOAD &&\r\n        this.messageBytes.length < this.rtspContentLength\r\n      ) {\r\n        // Copy data into the RTSP payload\r\n        this.messageBytes.push(data[index]);\r\n        index++;\r\n\r\n        if (this.messageBytes.length == this.rtspContentLength) {\r\n          const text = String.fromCharCode.apply(null, this.messageBytes);\r\n          const mediaHeaders = text.split(\"\\n\");\r\n\r\n          // Emit the RTSP message\r\n          this.emit(\r\n            \"log\",\r\n            String.fromCharCode.apply(null, this.messageBytes) + text,\r\n            \"S->C\"\r\n          );\r\n\r\n          this.emit(\r\n            \"response\",\r\n            this.rtspStatusLine,\r\n            this.rtspHeaders,\r\n            mediaHeaders\r\n          );\r\n          this.readState = ReadStates.SEARCHING;\r\n        }\r\n      } else {\r\n        // unexpected data\r\n        throw new Error(\r\n          \"Bug in RTSP data framing, please file an issue with the author with stacktrace.\"\r\n        );\r\n      }\r\n    } // end while\r\n  }\r\n\r\n  _sendInterleavedData(channel: number, buffer: Buffer): void {\r\n    if (!this._client) {\r\n      return;\r\n    }\r\n\r\n    const req = `${buffer.length} bytes of interleaved data on channel ${channel}`;\r\n    this.emit(\"log\", req, \"C->S\");\r\n\r\n    const header = new Buffer(4);\r\n    header[0] = 0x24; // ascii $\r\n    header[1] = channel;\r\n    header[2] = (buffer.length >> 8) & 0xff;\r\n    header[3] = (buffer.length >> 0) & 0xff;\r\n\r\n    const data = Buffer.concat([header, buffer]);\r\n    this._client.write(data);\r\n  }\r\n\r\n  _sendUDPData(host: string, port: number, buffer: Buffer): void {\r\n    const udp = dgram.createSocket(\"udp4\");\r\n    udp.send(buffer, 0, buffer.length, port, host, (err, bytes) => {\r\n      // TODO: Don't ignore errors.\r\n      udp.close();\r\n    });\r\n  }\r\n\r\n  _emptyReceiverReport(): Buffer {\r\n    const report = new Buffer(8);\r\n    const version = 2;\r\n    const paddingBit = 0;\r\n    const reportCount = 0; // an empty report\r\n    const packetType = 201; // Receiver Report\r\n    const length = report.length / 4 - 1; // num 32 bit words minus 1\r\n    report[0] = (version << 6) + (paddingBit << 5) + reportCount;\r\n    report[1] = packetType;\r\n    report[2] = (length >> 8) & 0xff;\r\n    report[3] = (length >> 0) & 0xff;\r\n    report[4] = (this.clientSSRC >> 24) & 0xff;\r\n    report[5] = (this.clientSSRC >> 16) & 0xff;\r\n    report[6] = (this.clientSSRC >> 8) & 0xff;\r\n    report[7] = (this.clientSSRC >> 0) & 0xff;\r\n\r\n    return report;\r\n  }\r\n\r\n  async _socketWrite(socket: net.Socket, data: Buffer): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n      setTimeout(() => {\r\n        socket.write(data, (error: any) => {\r\n          if (error) {\r\n            reject(error);\r\n          } else {\r\n            resolve(undefined);\r\n          }\r\n        })\r\n      }, 20);\r\n    })\r\n  }\r\n}\r\n\r\nexport { RTPPacket, RTCPPacket } from \"./util\";\r\n"]}